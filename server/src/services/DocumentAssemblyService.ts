import { Clause } from '../types';

export interface DocumentElement {
    type: 'HEADING' | 'PARAGRAPH' | 'FOOTER';
    text: string;
    level?: number;
}

interface AssemblyInput {
    template: {
        template_name: string;
        version: string;
        clauses: Clause[];
    };
    variables: Record<string, string>;
    selectedOptionalKeys: string[];
    metadata: {
        firm_name: string;
        draft_id: string;
        generation_date: string;
    };
}

interface AssemblyOutput {
    status: 'PASS' | 'FAIL';
    validation_errors: string[];
    elements?: DocumentElement[];
}

export class DocumentAssemblyService {
    public static assemble(input: AssemblyInput): AssemblyOutput {
        const errors: string[] = [];
        const { template, variables, selectedOptionalKeys, metadata } = input;

        // 1. Filter clauses based on type and selection
        let activeClauses = template.clauses.filter(clause => {
            if (clause.clause_type === 'locked' || clause.clause_type === 'variable') return true;
            if (clause.clause_type === 'optional' && selectedOptionalKeys.includes(clause.clause_key)) return true;
            return false;
        });

        // 2. Sort by order_index if present
        activeClauses = activeClauses.sort((a, b) => (a.order_index ?? 0) - (b.order_index ?? 0));

        // 3. Validation
        if (!template.template_name) errors.push("Document title is missing.");
        if (!template.version) errors.push("Template version is not referenced.");

        const elements: DocumentElement[] = [];

        // 4. Title Heading
        elements.push({ type: 'HEADING', text: template.template_name.toUpperCase(), level: 1 });

        let clauseCount = 1;
        for (const clause of activeClauses) {
            let clauseText = clause.clause_text;

            // Variable replacement logic
            const matches = clauseText.match(/{{\s*(\w+)\s*}}/g);
            if (matches) {
                for (const match of matches) {
                    const varKey = match.replace(/{{\s*|\s*}}/g, '');
                    const value = variables[varKey];

                    if (value === undefined || value === null || value === '') {
                        errors.push(`Required variable "${varKey}" in clause "${clause.clause_title}" is not populated.`);
                    } else {
                        const regex = new RegExp(`{{\\s*${varKey}\\s*}}`, 'g');
                        clauseText = clauseText.replace(regex, value);
                    }
                }
            }

            // Add Heading and Text as separate elements for better structure
            elements.push({ type: 'HEADING', text: `${clauseCount}. ${clause.clause_title}`, level: 2 });
            elements.push({ type: 'PARAGRAPH', text: clauseText });
            clauseCount++;
        }

        // 5. Final Placeholder Check
        const fullContentText = elements.map(e => e.text).join(' ');
        if (fullContentText.includes('{{') || fullContentText.includes('}}')) {
            errors.push("Template contains unresolved placeholders.");
        }

        if (errors.length > 0) {
            return {
                status: 'FAIL',
                validation_errors: errors
            };
        }

        // 6. Footer Metadata
        elements.push({
            type: 'FOOTER',
            text: `Generated by ${metadata.firm_name} | Template ${template.version} | ID: ${metadata.draft_id} | ${metadata.generation_date}`
        });

        return {
            status: 'PASS',
            validation_errors: [],
            elements
        };
    }
}
