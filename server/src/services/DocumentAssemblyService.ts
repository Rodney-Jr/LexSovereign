import { Clause } from '../types'; // Assuming types are available or will be defined

interface AssemblyInput {
    template: {
        template_name: string;
        version: string;
        clauses: Clause[];
    };
    variables: Record<string, string>;
    selectedOptionalKeys: string[];
    metadata: {
        firm_name: string;
        draft_id: string;
        generation_date: string;
    };
}

interface AssemblyOutput {
    status: 'PASS' | 'FAIL';
    validation_errors: string[];
    assembled_document?: string;
}

export class DocumentAssemblyService {
    public static assemble(input: AssemblyInput): AssemblyOutput {
        const errors: string[] = [];
        const { template, variables, selectedOptionalKeys, metadata } = input;

        // 1. Filter clauses based on type and selection
        let activeClauses = template.clauses.filter(clause => {
            if (clause.clause_type === 'locked' || clause.clause_type === 'variable') return true;
            if (clause.clause_type === 'optional' && selectedOptionalKeys.includes(clause.clause_key)) return true;
            return false;
        });

        // 2. Sort by order_index if present, otherwise maintain original order
        activeClauses = activeClauses.sort((a, b) => (a.order_index ?? 0) - (b.order_index ?? 0));

        // 3. Task B: Validation (Preliminary)
        if (!template.template_name) errors.push("Document title is missing.");
        if (!template.version) errors.push("Template version is not referenced.");

        // 4. Task A: Draft Assembly & Variable Replacement
        let documentContent = `${template.template_name.toUpperCase()}\n\n`;
        let clauseCount = 1;

        for (const clause of activeClauses) {
            let clauseText = clause.clause_text;

            // Find all variables in this clause
            const matches = clauseText.match(/{{\s*(\w+)\s*}}/g);
            if (matches) {
                for (const match of matches) {
                    const varKey = match.replace(/{{\s*|\s*}}/g, '');
                    const value = variables[varKey];

                    if (value === undefined || value === null || value === '') {
                        errors.push(`Required variable "${varKey}" in clause "${clause.clause_title}" is not populated.`);
                    } else {
                        // Use a regex with global flag to replace all instances of this variable
                        const regex = new RegExp(`{{\\s*${varKey}\\s*}}`, 'g');
                        clauseText = clauseText.replace(regex, value);
                    }
                }
            }

            documentContent += `${clauseCount}. ${clause.clause_title}\n${clauseText}\n\n`;
            clauseCount++;
        }

        // 5. Final Validation Check
        if (documentContent.includes('{{') || documentContent.includes('}}')) {
            errors.push("Template contains unresolved placeholders.");
        }

        if (errors.length > 0) {
            return {
                status: 'FAIL',
                validation_errors: errors
            };
        }

        // 6. Task C: Footer Metadata
        const footer = `----------------------------\nGenerated by ${metadata.firm_name}\nTemplate version ${template.version}\nDraft ID ${metadata.draft_id}\nGenerated on ${metadata.generation_date}`;
        documentContent += footer;

        return {
            status: 'PASS',
            validation_errors: [],
            assembled_document: documentContent.trim()
        };
    }
}
